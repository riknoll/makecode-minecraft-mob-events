const fs = require("fs");
const path = require("path");

const homeDir = process.argv.length == 2 ? "." : path.resolve(process.argv[2]);

const eventsRaw = fs.readFileSync(path.join(__dirname, "spawn_events.json"), "utf-8");
const events = JSON.parse(eventsRaw);

const extName = "makecode-minecraft-mob-events";
const nsName = "mobEvents";

const enums = [];
const funs = [];
const apis = [];
const docs = {};

for (const ent of Object.keys(events)) {
    const name = events[ent].name;
    const enumName = formatEnumName(name);
    const evs = events[ent].events;

    enums.push(`
    export enum ${enumName} {
        ${evs.map(e => `//% block="${e.description}"\n${formatEnumName(e.description)},`).join("\n")}
    }
    `);

    funs.push(`
    function _${enumName}(id: ${enumName}): string {
        switch (id) {
            ${evs.map(e => `case ${enumName}.${formatEnumName(e.description)}: return "${e.id}";`).join("\n")}
            default:
                player.errorMessage("Unknown ${enumName} value");
                return undefined;
        }
    }
    `);

    apis.push(`
        /**
         * Sends a command to all ${name} entities that are matched by the given selector.
         * This block uses EntitySelectors from this extension and not TargetSelectors
         * from the mobs category.
         *
         * @param selector An EntitySelector specifying which entities to send the command to
         * @param command The command to send to the selected entities
         *
         */
        //% blockId=mob_events_${enumName}
        //% block="send ${name} event $command to $selector"
        //% selector.shadow=mob_events_create_selector
        //% help=github:${extName}/docs/${formatDocsPageName(name)}
        export function execute${enumName}Command(selector: EntitySelector, command: ${enumName}): void {
            selector._setRule(_EntitySelectorArgument.Type, "${ent}");
            executeMobEvent(selector, _${enumName}(command));
        }
    `);

    docs[formatDocsPageName(name) + ".md"] = `
    # execute ${name} command

    Sends a command to all ${name} entities that are matched by the given selector. This
    block uses EntitySelectors from this extension and not TargetSelectors from the mobs
    category.

    \`\`\`sig
    ${nsName}.execute${enumName}Command(${nsName}.createSelector(), ${enumName}.${formatEnumName(evs[0].description)})
    \`\`\`

    ## Parameters

    * **selector**: A EntitySelector specifying which entities to send the command to
    * **command**: An ${enumName} for the command to send to the selected entities.

    \`\`\`package
    ${extName}=github:microsoft/${extName}
    \`\`\`
    `;
}

let enumOut = "";
for (const e of enums) {
    const lines = e.trim().split("\n");
    const newLines = [];
    for (let i = 0; i < lines.length; i++) {
        if (i === 0 || i === lines.length - 1) {
            newLines.push(indent(lines[i], 1));
        }
        else {
            newLines.push(indent(lines[i], 2));
        }
    }
    enumOut += newLines.join("\n") + "\n\n";
}

let funsOut = "";
for (const e of funs) {
    const lines = e.trim().split("\n");
    const newLines = [];
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (i === 0 || i === lines.length - 1) {
            newLines.push(indent(line, 1));
        }
        else if (line.startsWith("switch") || line.startsWith("}")) {
            newLines.push(indent(line, 2));
        }
        else if (line.startsWith("case") || line.startsWith("default")) {
            newLines.push(indent(line, 3));
        }
        else {
            newLines.push(indent(line, 4));
        }
    }
    funsOut += newLines.join("\n") + "\n\n";
}

if (!fs.existsSync(homeDir)) {
    fs.mkdirSync(homeDir, { recursive: true });
}

if (!fs.existsSync(path.join(homeDir, "docs"))) {
    fs.mkdirSync(path.join(homeDir, "docs"), { recursive: true });
}

let apisOut = "";
for (const e of apis) {
    const lines = e.trim().split("\n");
    const newLines = [];
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line.startsWith("/") || line.startsWith("export") || line.startsWith("}")) {
            newLines.push(indent(line, 1));
        }
        else if (line.startsWith("*")) {
            newLines.push(" " + indent(line, 1));
        }
        else {
            newLines.push(indent(line, 2));
        }
    }
    apisOut += newLines.join("\n") + "\n\n";
}

let out = `
// Autogenerated code DO NOT EDIT
namespace ${nsName} {
${apisOut}
${enumOut}
${funsOut}
}
// Autogenerated code DO NOT EDIT
`.trim() + "\n"


fs.writeFileSync(path.join(homeDir, "apis.g.ts"), out, "utf-8");

for (const docFile of Object.keys(docs)) {
    const content = docs[docFile].trim().split("\n").map(l => l.trim()).join("\n") + "\n";

    fs.writeFileSync(path.join(homeDir, "docs", docFile), content, "utf-8");
}

let config;

if (fs.existsSync(path.join(homeDir, "pxt.json"))) {
    config = JSON.parse(fs.readFileSync(path.join(homeDir, "pxt.json")));
}
else {
    config = {
        "name": extName,
        "version": "0.0.1",
        "description": "An extension for controlling mobs in MakeCode for Minecraft Education",
        "dependencies": {
            "core": "*"
        },
        "files": [],
        "testFiles": [
        ],
        "supportedTargets": [
            "minecraft"
        ],
        "preferredEditor": "tsprj"
    }
}

config.files = Object.keys(docs).map(d => `docs/${d}`).concat([
    "apis.g.ts",
    "main.ts",
    "README.md",
]);

fs.writeFileSync(path.join(homeDir, "pxt.json"), JSON.stringify(config, null, 4), "utf-8");

console.log("done");

function formatEnumName(name) {
    return name.split(" ").map(p => p.charAt(0).toUpperCase() + p.slice(1)).join("");
}

function formatDocsPageName(name) {
    return name.split(" ").join("-");
}

function indent(line, tabs) {
    let out = line.trim();

    for (let i = 0; i < tabs; i++) {
        out = "    " + out;
    }

    return out;
}